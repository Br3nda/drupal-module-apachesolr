<?php
// $Id: apachesolr_search.module,v 1.31 2010/08/13 21:16:22 pwolanin Exp $

/**
 * @file
 *   Provides a content search implementation for node content for use with the
 *   Apache Solr search application.
 */

/**
 * Implementation of hook_help().
 */
function apachesolr_search_help($section) {
  switch ($section) {
    case 'admin/config/search/apachesolr/index':
      if (variable_get('apachesolr_read_only', 0)) {
        return t('Operating in read-only mode; updates are disabled.');
      }
      $remaining = 0;
      $total = 0;
      // Collect the stats
      $status = apachesolr_index_status('apachesolr_search');
      $remaining += $status['remaining'];
      $total += $status['total'];

      return t('The search index is generated by !cron. %percentage of the site content has been sent to the server. There @items left to send.', array(
        '!cron' => l(t('running cron'), 'admin/reports/status/run-cron', array('query' => array('destination' => 'admin/config/search/apachesolr/index'))),
        '%percentage' => ((int)min(100, 100 * ($total - $remaining) / max(1, $total))) .'%',
        '@items' => format_plural($remaining, t('is 1 item'), t('are @count items')
      )));
  }
}

/**
 * Implements hook_menu().
 */
function apachesolr_search_menu() {
  $items['admin/config/search/apachesolr/query-fields'] = array(
    'title'            => 'Search fields',
    'page callback'    => 'apachesolr_search_settings_page',
    'access arguments' => array('administer search'),
    'weight'           => 1,
    'type'             => MENU_LOCAL_TASK,
    'file'             => 'apachesolr_search.admin.inc',
  );
  $items['admin/config/search/apachesolr/content-bias'] = array(
    'title'            => 'Content bias settings',
    'page callback'    => 'apachesolr_boost_settings_page',
    'access arguments' => array('administer search'),
    'weight'           => 1,
    'type'             => MENU_LOCAL_TASK,
    'file'             => 'apachesolr_search.admin.inc',
  );

  return $items;
}

 /**
 * Implements hook_menu_alter().
 */
function apachesolr_search_menu_alter(&$menu) {

  if (variable_get('apachesolr_search_make_default', 0)) {
    if (isset($menu['search/node/%menu_tail'])) {
      // Hide the node search tab.
      $menu['search/node/%menu_tail']['type'] = MENU_CALLBACK;
      $menu['search/node/%menu_tail']['title'] = 'Search';
    }
  }
  if (variable_get('apachesolr_search_taxonomy_links', 0)) {
    if (isset($menu['taxonomy/term/%taxonomy_term'])) {
      $menu['taxonomy/term/%taxonomy_term']['page callback'] = 'apachesolr_search_taxonomy_term_page';
      $menu['taxonomy/term/%taxonomy_term']['file path'] = drupal_get_path('module', 'apachesolr_search');
      $menu['taxonomy/term/%taxonomy_term']['file'] = 'apachesolr.taxonomy.inc';
    }
  }
}

/**
 * Implements hook_cron(). Indexes nodes.
 */
function apachesolr_search_cron() {
  $cron_limit = variable_get('apachesolr_cron_limit', 50);
  $rows = apachesolr_get_nodes_to_index('apachesolr_search', $cron_limit);
  apachesolr_index_nodes($rows, 'apachesolr_search');
}

/**
 * Implements hook_apachesolr_types_exclude().
 */
function apachesolr_search_apachesolr_types_exclude($namespace) {
  if ($namespace == 'apachesolr_search') {
    $excluded_types = variable_get('apachesolr_search_excluded_types', array());
    return array_filter($excluded_types);
  }
}

/**
 * Implementation of hook_search_info().
 */
function apachesolr_search_search_info() {
  return variable_get('apachesolr_search_search_info', array(
    'title' => 'Search',
    'path' => 'content',
    'conditions_callback' => 'apachesolr_search_conditions',
  ));
}

/**
 * Implementation of hook_search_reset().
 */
function apachesolr_search_search_reset(){
  apachesolr_clear_last_index('apachesolr_search');
}

/**
 * Implementation of hook_search_status().
 */
function apachesolr_search_search_status(){
  return apachesolr_index_status('apachesolr_search');
}

/**
 * Implementation of hook_search_execute().
 */
function apachesolr_search_search_execute($keys = NULL, $conditions = NULL) {
  $filters = isset($conditions['filters']) ? $conditions['filters'] : '';
  $solrsort = isset($_GET['solrsort']) ? $_GET['solrsort'] : '';

  try {
    return apachesolr_search_run($keys, $filters, $solrsort, 'search/' . arg(1), pager_find_page());
  }
  catch (Exception $e) {
    watchdog('Apache Solr', nl2br(check_plain($e->getMessage())), NULL, WATCHDOG_ERROR);
    apachesolr_failure(t('Solr search'), $keys);
  }
}

/**
 * Implementation of a search_view() conditions callback.
 */
function apachesolr_search_conditions() {
  $conditions = array();

  if (isset($_GET['filters']) && trim($_GET['filters'])) {
    $conditions['filters'] = trim($_GET['filters']);
  }
  if (variable_get('apachesolr_search_browse', 'browse') == 'results') {
    // Set a condition so the search is triggered.
    $conditions['apachesolr_search_browse'] = 'results';
  }
  return $conditions;
}

function apachesolr_search_theme_search_results($search_result, $type){
  if (isset($search_result) && is_array($search_result) && count($search_result)) {
    if (module_hook($type, 'search_page')) {
      $content = module_invoke($type, 'search_page', $search_result);
    }
    else {
      $content = theme('search_results', array('results' => $search_result, 'type' => $type));
    }
  }
  else if ($search_result) {
    $content = theme('search_results_listing', array('title' => t('Search results'), 'content' => $search_result));
  }
  else {
    $content = theme('search_results_listing', array('title' => t('Your search yielded no results'), 'content' => theme('apachesolr_search_noresults')));
  }

  return $content;
}
/**
 * Implements hook_apachesolr_document_handlers().
 *
 * @param string $type
 *   Entity type. 'node', 'comment', and so forth. Used to evaluate whether this module
 *   should be interested in creating documents.
 * @param string $namespace
 *   Usually the name of the module that is initiating indexing. In this case
 *   we want to register a handler if the namespace is 'apachesolr_search'.
 * @return array $handlers
 *   An array of strings that are function names. Each function returns a $document from
 *   an entity (of type $type).
 */
function apachesolr_search_apachesolr_document_handlers($type, $namespace) {
  if ($type == 'node' && $namespace == 'apachesolr_search') {
    return array('apachesolr_node_to_document');
  }
}

/**
 * Execute an empty search (match all documents) and show a listing of all enabled facets.
 */
function apachesolr_search_browse($keys = '', $filters = '', $solrsort = '', $base_path = '') {
  global $user, $theme_key;
  $query = apachesolr_drupal_query($keys, $filters, $solrsort, $base_path);
  $params = array(
    'start' => 0,
    'rows' => 0,
    'facet' => 'true',
    'facet.mincount' => 1,
    'facet.sort' => 'true'
  );
  apachesolr_search_add_facet_params($params, $query);
  $solr = apachesolr_get_solr();
  apachesolr_current_query($query);
  apachesolr_modify_query($query, $params, 'apachesolr');
  $response = $solr->search('', $params['start'], $params['rows'], $params);
  if (empty($response)) {
    return;
  }
  apachesolr_static_response_cache($response);
  apachesolr_has_searched(TRUE);

  //this sets $theme_key global variable
  drupal_theme_initialize();

  // Get blocks for all enabled filters
  $blocks = array();
  $rids = array_keys($user->roles);
  foreach (apachesolr_get_enabled_facets() as $module => $module_facets) {
    if (!module_exists($module)) {
      // When modules are disabled their facet settings may remain.
      continue;
    }
    foreach ($module_facets as $delta => $facet_field) {
      if ($delta == 'currentsearch') {
        continue;
      }
      $fc = $response->facet_counts;
      if ((isset($fc->facet_fields->$facet_field) && count((array) $fc->facet_fields->$facet_field) > 0) ||
          (isset($fc->facet_dates->$facet_field) && count((array) $fc->facet_dates->$facet_field) > 0)) {
        // This bit is modeled on block.module, block_list().
        $query = db_select('block', 'b');
        $br_alias = $query->leftJoin('block_role', 'br', 'b.module = br.module AND b.delta = br.delta');
        $query
          ->fields('b')
          ->distinct()
          ->condition('b.module', $module)
          ->condition('b.delta', $delta)
          ->condition('b.theme', $theme_key)
          ->condition('b.status', 1)
          ->condition(db_or()->condition('br.rid', $rids, 'IN')->isNull('br.rid'))
          ->range(0, 1);
        $query->addTag('node_access');
        $result = $query->execute();
        $block = $result->fetchObject();
        if ($block) {
          // TODO: not sure if we should show facets that have no corresponding enabled blocks here.
          // Anyways without this condition there will be warnings if fetchObject() returns false
          $hook_block = (object)module_invoke($module, 'block_view', $delta);
          $block->content = $hook_block->content;
          $block->subject = str_replace(t('Filter by '), t('Browse by '), $hook_block->subject);
          // We can safely assume these values, since we're taking over the block display.
          $block->visibility = TRUE;
          $block->enabled = TRUE;
          // This hook is made up. It should be in Drupal core, and it is quite useful.
          // Including it here because it has saved the day on projects.
          drupal_alter('block', $block);
          if ($block->enabled && $block->visibility) {
            $blocks["{$module}_{$delta}"] = $block;
          }
        }
      }
    }
  }
  apachesolr_has_searched(FALSE);
  usort($blocks, create_function('$a, $b', 'return $a->weight - $b->weight;'));
  return $blocks;
}

/**
 * Theming function that shows a groups of blocks so users can start a search from a filter.
 *
 * @param $blocks an array of block objects.
 */
function theme_apachesolr_browse_blocks($vars) {
  $blocks = $vars['blocks'];
  $result = "<div class='apachesolr_browse_block'><h2>" . t('Browse available categories') .'</h2>';
  $result .= '<p>' . t('Pick a category to launch a search.') . '</p>';
  foreach ($blocks as $facet_field => $block) {
    //$result .= theme('block', array('block' => $block));
    $result .= theme('block', array('elements' => array('#block' => $block, '#children' => $block->content)));

  }
  $result .= '</div>';

  return $result;
}

/**
 * Execute a search results based on keyword, filter, and sort strings.
 *
 * @param $keys
 * @param $filterstring
 * @param $solrsort
 * @param $base_path
 *   For constructing filter and sort links. Leave empty unless the links need to point somewhere
 *   other than the base path of the current request.
 * @param integer $page
 *   For pagination.
 * @param $caller
 * @return Apache_Solr_Response $response
 * @throws Exception
 */
function apachesolr_search_run($keys, $filterstring, $solrsort, $base_path = '', $page = 0, $caller = 'apachesolr_search') {
  $params = array();
  // This is the object that knows about the query coming from the user.
  $query = apachesolr_drupal_query($keys, $filterstring, $solrsort, $base_path);
  if (empty($query)) {
    throw new Exception(t('Could not construct a Solr query in function apachesolr_search_search()'));
  }

  $params += apachesolr_search_basic_params($query);
  if ($keys) {
    $params += apachesolr_search_highlighting_params($query);
    $params += apachesolr_search_spellcheck_params($query);
  }
  else {
    // No highlighting, use the teaser as a snippet.
    $params['fl'] .= ',teaser';
  }
  apachesolr_search_add_facet_params($params, $query);
  apachesolr_search_add_boost_params($params, $query, apachesolr_get_solr());

  list($final_query, $response) = apachesolr_do_query($caller, $query, $params, $page);
  apachesolr_has_searched(TRUE);
  // Add search terms and filters onto the breadcrumb.
  // We use the original $query to avoid exposing, for example, nodeaccess
  // filters in the breadcrumb.
  drupal_set_breadcrumb(array_merge(menu_get_active_breadcrumb(), $query->get_breadcrumb()));
  return apachesolr_search_process_response($response, $final_query, $params);
}

// TODO: Why does this take the $query object?
function apachesolr_search_basic_params($query) {
  $params = array(
    'fl' => 'id,nid,title,comment_count,type,created,changed,score,path,url,uid,name',
    'rows' => variable_get('apachesolr_rows', 10),
    'facet' => 'true',
    'facet.mincount' => 1,
    'facet.sort' => 'true'
  );
  return $params;
}

/**
 * Add highlighting settings to the search params.
 *
 * These settings are set in solrconfig.xml.
 * See the defaults there.
 * If you wish to override them, you can via settings.php
 */
function apachesolr_search_highlighting_params($query) {
  $params['hl'] = variable_get('apachesolr_hl_active', NULL);
  $params['hl.fragsize']= variable_get('apachesolr_hl_textsnippetlength', NULL);
  $params['hl.simple.pre'] = variable_get('apachesolr_hl_pretag', NULL);
  $params['hl.simple.post'] = variable_get('apachesolr_hl_posttag', NULL);
  $params['hl.snippets'] = variable_get('apachesolr_hl_numsnippets', NULL);
  $params['hl.fl'] = variable_get('apachesolr_hl_fieldtohightlight', NULL);
  return $params;
}

function apachesolr_search_spellcheck_params($query) {
  $params = array();
  if (variable_get('apachesolr_search_spellcheck', TRUE)) {
    //Add new parameter to the search request
    $params['spellcheck.q'] = $query->get_query_basic();
    $params['spellcheck'] = 'true';
  }
  return $params;
}

function apachesolr_search_add_facet_params(&$params, $query) {
  $facet_query_limits = variable_get('apachesolr_facet_query_limits', array());
  $facet_missing = variable_get('apachesolr_facet_missing', array());
  $facet_info = apachesolr_get_facet_definitions();

  foreach (apachesolr_get_enabled_facets() as $module => $module_facets) {
    foreach ($module_facets as $delta => $facet_field) {
      // Checking the block visibility saves us from adding facet fields to the query
      // which won't be used.
      if (apachesolr_block_visibility($query, $module, $delta)) {
        // TODO: generalize handling of date and range facets.
        // TODO: put field type in the facet definitions.
        // NOTE: This is a dependency on the apachesolr_date module. Using function_exists to avoid problems.
        if (isset($facet_info[$module][$delta]['field_type'])
              && in_array($facet_info[$module][$delta]['field_type'], array('date', 'datetime', 'datestamp'))
              && function_exists('apachesolr_date_search_date_range')) {
          list($start, $end, $gap) = apachesolr_date_search_date_range($query, $facet_field);
          if ($gap) {
            $params['facet.date'][] = $facet_field;
            $params['f.'. $facet_field .'.facet.date.start'] = $start;
            $params['f.'. $facet_field .'.facet.date.end'] = $end;
            $params['f.'. $facet_field .'.facet.date.gap'] = $gap;
          }
        }
        elseif ($module == 'apachesolr_search' && ($facet_field == 'created' || $facet_field == 'changed')) {
          list($start, $end, $gap) = apachesolr_search_date_range($query, $facet_field);
          if ($gap) {
            $params['facet.date'][] = $facet_field;
            $params['f.'. $facet_field .'.facet.date.start'] = $start;
            $params['f.'. $facet_field .'.facet.date.end'] = $end;
            $params['f.'. $facet_field .'.facet.date.gap'] = $gap;
          }
        }
        else {
          $ex = '';
          if ($facet_info[$module][$delta]['operator'] == 'OR') {
            $ex = "{!ex=$facet_field}";
          }
          $params['facet.field'][] = $ex . $facet_field;
          // Facet limits
          if (isset($facet_query_limits[$module][$delta])) {
            $params['f.' . $facet_field . '.facet.limit'] = $facet_query_limits[$module][$delta];
          }
          // Facet missing
          if (!empty($facet_missing[$module][$delta])) {
            $params['f.' . $facet_field . '.facet.missing'] = 'true';
          }
        }
      }
    }
  }

  if (!empty($params['facet.field'])) {
    // Add a default limit for fields where no limit was set.
    $params['facet.limit'] = variable_get('apachesolr_facet_query_limit_default', 20);
  }
}

function apachesolr_search_add_boost_params(&$params, $query, $solr) {
  // Note - we have query fields set in solrconfig.xml, which will operate when
  // none are set.
  $qf = variable_get('apachesolr_search_query_fields', array());
  $fields = $solr->getFields();
  if ($qf && $fields) {
    foreach ($fields as $field_name => $field) {
      if (!empty($qf[$field_name])) {
        if ($field_name == 'body') {
          // Body is the only normed field.
          $qf[$field_name] *= 40.0;
        }
        $params['qf'][] = $field_name . '^'. $qf[$field_name];
      }
    }
  }

  $data = $solr->getLuke();
  if (isset($data->index->numDocs)) {
    $total = $data->index->numDocs;
  }
  else {
    $total = db_query("SELECT COUNT(nid) FROM {node}")->fetchField();
  }
  // For the boost functions for the created timestamp, etc we use the
  // standard date-biasing function, as suggested (but steeper) at
  // http://wiki.apache.org/solr/DisMaxRequestHandler
  // rord() returns 1 for the newset doc, and the number in the index for
  // the oldest doc.  The function is thus: $total/(rord()*$steepness + $total).
  $date_settings = variable_get('apachesolr_search_date_boost', '4:200.0');
  list($date_steepness, $date_boost) = explode(':', $date_settings);
  if ($date_boost) {
    $params['bf'][] = "recip(rord(created),$date_steepness,$total,$total)^$date_boost";
  }
  // Boost on comment count.
  $comment_settings = variable_get('apachesolr_search_comment_boost', '0:0');
  list($comment_steepness, $comment_boost) = explode(':', $comment_settings);
  if ($comment_boost) {
    $params['bf'][] = "recip(rord(comment_count),$comment_steepness,$total,$total)^$comment_boost";
  }
  // Boost for a more recent comment or node edit.
  $changed_settings = variable_get('apachesolr_search_changed_boost', '0:0');
  list($changed_steepness, $changed_boost) = explode(':', $changed_settings);
  if ($changed_boost) {
    $params['bf'][] = "recip(rord(last_comment_or_change),$changed_steepness,$total,$total)^$changed_boost";
  }
  // Boost for nodes with sticky bit set.
  $sticky_boost = variable_get('apachesolr_search_sticky_boost', 0);
  if ($sticky_boost) {
    $params['bq'][] = "sticky:true^$sticky_boost";
  }
  // Boost for nodes with promoted bit set.
  $promote_boost = variable_get('apachesolr_search_promote_boost', 0);
  if ($promote_boost) {
    $params['bq'][] = "promote:true^$promote_boost";
  }
  // Modify the weight of results according to the node types.
  $type_boosts = variable_get('apachesolr_search_type_boosts', array());
  if (!empty($type_boosts)) {
    foreach ($type_boosts as $type => $boost) {
      // Only add a param if the boost is != 0 (i.e. > "Normal").
      if ($boost) {
        $params['bq'][] = "type:$type^$boost";
      }
    }
  }
}

function apachesolr_search_process_response($response, $query, $params) {
  $results = array();
  // We default to getting snippets from the body.
  $hl_fl = isset($params['hl.fl']) ? $params['hl.fl'] : 'body';
  $total = $response->response->numFound;
  pager_default_initialize($total, $params['rows']);
  if ($total > 0) {
    foreach ($response->response->docs as $doc) {
      $extra = array();

      // Find the nicest available snippet.
      if (isset($response->highlighting->{$doc->id}->$hl_fl)) {
        $snippet = theme('apachesolr_search_snippets', array('doc' => $doc, 'snippets' => $response->highlighting->{$doc->id}->$hl_fl));
      }
      elseif (isset($doc->teaser)) {
        $snippet = theme('apachesolr_search_snippets', array('doc' => $doc, 'snippets' => array(truncate_utf8($doc->teaser, 256, TRUE))));
      }
      else {
        $snippet = '';
      }

      if (!isset($doc->body)) {
        $doc->body = $snippet;
      }
      $doc->created = strtotime($doc->created);
      $doc->changed = strtotime($doc->changed);
      $extra = array();
      $extra['comments'] = format_plural($doc->comment_count, '1 comment', '@count comments');
      // Allow modules to alter each document and its extra information.
      drupal_alter('apachesolr_search_result', $doc, $extra);
      $fields = array();
      foreach ($doc->getFieldNames() as $field_name) {
        $fields[$field_name] = $doc->getField($field_name);
      }
      $results[] = array(
        'link' => url($doc->path, array('absolute' => TRUE)),
        'type' => apachesolr_search_get_type($doc->type),
        // template_preprocess_search_result() runs check_plain() on the title
        // again.  Decode to correct the display.
        'title' => htmlspecialchars_decode($doc->title, ENT_QUOTES),
        'user' => theme('username', array('account' => $doc)),
        'date' => $doc->created,
        'node' => $doc,
        'extra' => $extra,
        'score' => $doc->score,
        'snippet' => $snippet,
        'fields' => $fields,
      );
    }

    // Hook to allow modifications of the retrieved results
    foreach (module_implements('apachesolr_process_results') as $module) {
      $function = $module .'_apachesolr_process_results';
      $function($results);
    }
  }
  return $results;
}

function apachesolr_search_date_range($query, $facet_field) {
  foreach ($query->get_filters($facet_field) as $filter) {
    // If we had an ISO date library we could use ISO dates
    // directly.  Instead, we convert to Unix timestamps for comparison.
    // Only use dates if we are able to parse into timestamps.
    $start = strtotime($filter['#start']);
    $end = strtotime($filter['#end']);
    if ($start && $end && ($start < $end)) {
        $start_iso = $filter['#start'];
        $end_iso = $filter['#end'];
      // Determine the drilldown gap for this range.
      $gap = apachesolr_date_gap_drilldown(apachesolr_date_find_query_gap($start_iso, $end_iso));
    }
  }
  // If there is no $delta field in query object, get initial
  // facet.date.* params from the DB and determine the best search
  // gap to use.  This callback assumes $delta is 'changed' or 'created'.
  if (!isset($start_iso)) {
    $start_iso = apachesolr_date_iso(db_query("SELECT MIN($facet_field) FROM {node} WHERE status = 1")->fetchField());
    // Subtract one second, so that this range's $end_iso is not equal to the
    // next range's $start_iso.
    $end_iso = apachesolr_date_iso(db_query("SELECT MAX($facet_field) FROM {node} WHERE status = 1")->fetchField() - 1);
    $gap = apachesolr_date_determine_gap($start_iso, $end_iso);
  }
  // Return a query range from the beginning of a gap period to the beginning
  // of the next gap period.  We ALWAYS generate query ranges of this form
  // and the apachesolr_date_*() helper functions require it.
  return array("$start_iso/$gap", "$end_iso+1$gap/$gap", "+1$gap");
}


/**
 * Helper function, finds node types that are tagged by the specified vocabulary
 */

function apachesolr_search_vocabulary_content_types($vid){
  $fields = field_info_fields();
  $types = array();
  foreach (field_info_instances('node') as $bundle_name => $bundle) {
    foreach ($bundle as $field_name => $inst){
      $f = $fields[$field_name];
      if ($f['type'] == 'taxonomy_term_reference' && $f['settings']['allowed_values'][0]['vid'] == $vid) {
        $types[] = $bundle_name;
      }
    }
  }
  return array_unique($types);
}

/**
 * Implements hook_apachesolr_facets().
 *
 * Returns an array keyed by block delta.
 */
function apachesolr_search_apachesolr_facets() {
  $facets = array();
  $facets['type'] = array(
    'info' => t('Node attribute: Filter by content type'),
    'facet_field' => 'type',
  );
  $facets['uid'] = array(
    'info' => t('Node attribute: Filter by author'),
    'facet_field' => 'uid',
  );
  $facets['language'] = array(
    'info' => t('Node attribute: Filter by language'),
    'facet_field' => 'language',
  );

  $facets['changed'] = array(
    'info' => t('Node attribute: Filter by updated date'),
    'facet_field' => 'changed',
  );
  $facets['created'] = array(
    'info' => t('Node attribute: Filter by post date'),
    'facet_field' => 'created',
  );

  // A book module facet.
  if (module_exists('book')) {
    $facets['is_book_bid'] = array(
      'info' => t('Book: Filter by Book'),
      'facet_field' => 'is_book_bid',
      'content_types' => variable_get('book_allowed_types', array('book')),
    );
  }

  // Get field facets.
  $fields = apachesolr_node_fields();
  foreach ($fields as $index_key => $field_info) {
    $facets[$index_key] = array(
        'info' => t('@module_name Field: Filter by @field_dname (@field_name)', array('@module_name' => $field_info['module_name'], '@field_name' => $field_info['field']['field_name'], '@field_dname' => $field_info['display_name'])),
        'facet_field' => $index_key,
        'content_types' => $field_info['content_types'],
    );
  }

  return $facets;
}


/**
 * Implements hook_block_info().
 */
function apachesolr_search_block_info(){
  $enabled_facets = apachesolr_get_enabled_facets('apachesolr_search');
  $facets = apachesolr_search_apachesolr_facets();
  // Add the blocks
  $blocks = array();
  foreach ($enabled_facets as $delta => $facet_field) {
    if (isset($facets[$delta])) {
      $blocks[$delta] = $facets[$delta] + array('cache' => DRUPAL_CACHE_PER_PAGE);
    }
  }
  $blocks['currentsearch'] = array(
    'info' => t('Apache Solr Search: Current search'),
    'cache' => DRUPAL_CACHE_PER_PAGE,
  );
  return $blocks;
}

/**
 * Implements hook_block_view().
 */
function apachesolr_search_block_view($delta = ''){
  if (apachesolr_has_searched()) {
    // Get the query and response. Without these no blocks make sense.
    $response = apachesolr_static_response_cache();
    if (empty($response)) {
      return;
    }
    $query = apachesolr_current_query();

    $facets = apachesolr_get_enabled_facets('apachesolr_search');

    if (empty($facets[$delta]) && ($delta != 'currentsearch')) {
      return;
    }

    if (!apachesolr_block_visibility($query, 'apachesolr_search', $delta)) {
      return;
    }

    switch ($delta) {
      case 'currentsearch':
        return apachesolr_search_currentsearch_block($response, $query);
      case 'is_book_bid':
        return apachesolr_facet_block($response, $query, 'apachesolr_search', $delta, t('Filter by book'), 'apachesolr_search_get_book');
      case 'language':
        return apachesolr_facet_block($response, $query, 'apachesolr_search', $delta, t('Filter by language'), 'apachesolr_search_language_name');
      case 'uid':
        return apachesolr_facet_block($response, $query, 'apachesolr_search', $delta, t('Filter by author'), 'apachesolr_search_get_username');
      case 'type':
        return apachesolr_facet_block($response, $query, 'apachesolr_search', $delta, t('Filter by type'), 'apachesolr_search_get_type');
      case 'changed':
        return apachesolr_date_facet_block($response, $query, 'apachesolr_search', $delta, t('Filter by modification date'));
      case 'created':
        return apachesolr_date_facet_block($response, $query, 'apachesolr_search', $delta, t('Filter by post date'));
      default:
        if ($fields = apachesolr_node_fields()) {
          if (isset($fields[$delta])) {
            // The $delta is the index key.
            $field_info = $fields[$delta];
            $callback = $field_info['display_callback'] ? $field_info['display_callback'] : FALSE;
            $block_function = ($field_info['facet_block_callback'] && function_exists($field_info['facet_block_callback'])) ? $field_info['facet_block_callback'] : 'apachesolr_facet_block';
            return $block_function($response, $query, 'apachesolr_search', $delta, t('Filter by @field', array('@field' => $field_info['display_name'])), $callback);
          }
        }
        break;
    }
  }
}

/**
 * Implements of hook_block_configure().
 */
function apachesolr_search_block_configure($delta = ''){
  if ($delta != 'currentsearch') {
    return apachesolr_facetcount_form('apachesolr_search', $delta);
  }
}

/**
 * Implements of hook_block_save().
 */
function apachesolr_search_block_save($delta = '', $edit = array()){
  if ($delta != 'currentsearch') {
    apachesolr_facetcount_save($edit);
  }
}

/**
 * Generate a list including the field and all its children.
 */
function apachesolr_search_collect_children($field) {
  $remove[] = $field;
  if (!empty($field['#children'])) {
    foreach ($field['#children'] as $child_field) {
      $remove = array_merge($remove, apachesolr_search_collect_children($child_field));
    }
  }
  return $remove;
}

/**
 * Generate the facet block for a taxonomy vid delta.
 */
function apachesolr_search_taxonomy_facet_block($response, $query, $module, $delta, $filter_by, $facet_callback = FALSE) {
  $vid = substr($delta, 7);
  if (!module_exists('taxonomy') || !is_numeric($vid)) {
    return;
  }

  // Check that we have a response and a valid vid.
  if (is_object($response->facet_counts->facet_fields->$delta) && ($vocab = taxonomy_vocabulary_load($vid))) {
    $reflect_hierarchy = apachesolr_search_get_hierarchical_vocabularies();
    $contains_active = FALSE;
    $facets = array();

    foreach ($response->facet_counts->facet_fields->$delta as $tid => $count) {
       // TODO - for now we don't handle facet missing.
      if ($tid != '_empty_') {
        $active = $query->has_filter($delta, $tid);
        if ($active) {
          $contains_active = TRUE;
        }
        $facets[$tid] = array(
          '#name' => $delta,
          '#value' => $tid,
          '#exclude' => FALSE,
          '#count' => $count,
          '#parent' => 0,
          '#children' => array(),
          '#has_children' => FALSE,
          '#active' => $active,
        );
      }
    }

    if ($facets && $reflect_hierarchy[$vocab->vid]) {
      $tids = array_keys($facets);
      // @todo: faster as 2x separate queries?
      $result = db_query("SELECT tid, parent FROM {taxonomy_term_hierarchy} WHERE parent > 0 AND (tid IN (:tids) OR parent IN (:tids))", array(':tids' => $tids));
      foreach($result as $term){
        // Mark all terms that are parents for later CSS class.
        // We assume data in the Solr index is complete - potential for some
        // breakage here.
        if (isset($facets[$term->parent])) {
          $facets[$term->parent]['#has_children'] = TRUE;
          if (isset($facets[$term->tid])) {
            $facets[$term->tid]['#parent'] = $term->parent;
            // Use a reference so we see the updated data.
            $facets[$term->parent]['#children'][] = &$facets[$term->tid];
          }
        }
      }

      // Check for the case like starting on a taxonomy/term/$tid page
      // where parents are not marked as active.
      // TODO: can we make this more efficient?
      do {
        $added_active = FALSE;
        foreach ($facets as $tid => $field) {
          if ($field['#active'] && $field['#parent'] && !$facets[$field['#parent']]['#active']) {
            // This parent has an active child.
            $added_active = TRUE;
            $query->add_filter($delta, $field['#parent']);
            $facets[$field['#parent']]['#active'] = TRUE;
          }
        }
      } while ($added_active);
      foreach ($facets as $tid => $field) {
        if (!empty($field['#parent'])) {
          // We will render it via its parent.
          unset($facets[$tid]);
        }
      }
    }

    $items = apachesolr_search_nested_facet_items($query, $facets, $response->response->numFound);
    // Process all terms into an item list
    if ($items && ($response->response->numFound > 1 || $contains_active)) {
      $initial_limits = variable_get('apachesolr_facet_query_initial_limits', array());
      $limit = isset($initial_limits['apachesolr_search'][$delta]) ? $initial_limits['apachesolr_search'][$delta] : variable_get('apachesolr_facet_query_initial_limit_default', 10);
      return array(
        'subject' => t('Filter by @name', array('@name' => $vocab->name)),
        'content' => theme('apachesolr_facet_list', array('items' => $items, 'display_limit' => $limit)),
      );
    }
  }
}

/**
 * Recursive function that returns a nested array of facet values for use with
 * theme_item_list().
 *
 * @param $query
 *   The current Solr query.
 * @param $facets
 *   Array of facet items to prepare for rendering, possibly as nested lists.
 * @param $num_found
 *   The number of documents in the current response.
 * @param $sort
 *   If true, the returned list will be sorted based on the count of each
 *   facets, it's text representation and wither it's active.  If false,
 *   the facets will be returned in the order they were received.
 */
function apachesolr_search_nested_facet_items($query, $facets, $num_found, $sort = TRUE) {
  $facet_query_sorts = variable_get('apachesolr_facet_query_sorts', array());
  $items = array();
  foreach ($facets as $field) {
    $facet_text = '';
    $field_name = $field['#name'];
    if (function_exists('taxonomy_term_load')) {
      // Taxonomy filters in the query string use the tid field.
      if ($field_name == 'tid') {
        // Each taxonomy vocabulary in the Solr index uses its own field.
        $term = taxonomy_term_load($field['#value']);
        $field_name = 'im_vid_' . $term->vid;
      }
    }
    $facet_definition = apachesolr_get_facet_definition_by_field_name($field_name);
    if (isset($facet_definition['display_callback'])) {
      $function = $facet_definition['display_callback'];
      if (function_exists($function)) {
        $facet_text = $function($field['#value'], $field);
      }
    }
    if (!$facet_text) {
      $breadcrumb_name = 'apachesolr_breadcrumb_' . $field['#name'];
      drupal_alter('apachesolr_theme_breadcrumb', $breadcrumb_name);
      $facet_text = theme($breadcrumb_name, array('field' => $field, 'exclude' => $field['#exclude']));
    }
    if (!$facet_text) {
      $facet_text = $field['#value'];
    }

    $active = !empty($field['#active']);

    $link = array();
    $new_query = clone $query;
    if ($active) {
      foreach (apachesolr_search_collect_children($field) as $child) {
        $new_query->remove_filter($child['#name'], $child['#value']);
      }
      $options['query'] = $new_query->get_url_queryvalues();
      $link['data'] = theme('apachesolr_unclick_link', array(
        'facet_text' => $facet_text,
        'path' => $new_query->get_path(),
        'options' => $options));
    }
    else {
      $new_query->add_filter($field['#name'], $field['#value']);
      $options = array('query' => $new_query->get_url_queryvalues());
      $link['data'] = theme('apachesolr_facet_link', array(
        'facet_text' => $facet_text,
        'path' => $new_query->get_path(),
        'options' => $options,
        'count' => $field['#count'],
        'active' => FALSE,
        'num_found' => $num_found));
    }

    if ($active) {
      // '*' sorts before all numbers.
      $sortpre = '*';
    }
    elseif (isset($facet_query_sorts['apachesolr_search'][$field_name]) && strpos($facet_query_sorts['apachesolr_search'][$field_name], 'index key') === 0) {
      // If this block is to be alphabetically sorted by key, change $sortpre.
      $sortpre = $field_name;
    }
    elseif (isset($facet_query_sorts['apachesolr_search'][$field_name]) && strpos($facet_query_sorts['apachesolr_search'][$field_name], 'index') === 0) {
      // If this block is to be alphabetically/numerically sorted by value, change $sortpre.
      $sortpre = $facet_text;
    }
    else {
      $sortpre = 1000000 - $field['#count'];
    }

    // We don't display children unless the parent is clicked.
    if (!empty($field['#children']) && $field['#active'] == TRUE) {
      $link['children'] = apachesolr_search_nested_facet_items($query, $field['#children'], $num_found, $sort);
      $link['class'] = "expanded-facet";
    }
    elseif (!empty($field['#has_children'])) {
      $link['class'] = "collapsed";
    }
    $items[$sortpre . '*' . $facet_text . $field['#name'] . $field['#value']] = $link;
  }

  if ($sort && $items) {
    switch ($facet_query_sorts['apachesolr_search'][$field_name]) {
      case 'index numeric asc':
        ksort($items, SORT_NUMERIC);
        break;
      case 'index numeric desc':
        krsort($items, SORT_NUMERIC);
        break;
      case 'index desc':
      case 'index key desc':
        krsort($items, SORT_STRING);
        break;
      case 'index asc':
      case 'index key asc':
      default:
        ksort($items, SORT_STRING);
        break;
    }
  }
  return array_values($items);
}


function apachesolr_search_taxonomy_get_term($tid) {
  if (function_exists('taxonomy_term_load')) {
    $term = taxonomy_term_load($tid);
    return $term['name'];
  }
}

/**
 * Callback function for the 'Filter by book' facet block.
 */
function apachesolr_search_get_book($facet, &$options) {
  if (is_numeric($facet)) {
    return db_query('SELECT title FROM {node} WHERE nid = :nid', array(':nid' => $facet))->fetchField();
  }
  else {
    $options['html'] = TRUE;
    return theme('placeholder', t('Not in any book'));
  }
}

function apachesolr_search_language_name($lang) {
  static $list = NULL;

  if (!isset($list)) {
    if (function_exists('locale_language_list')) {
      $list = locale_language_list();
    }
    $list['und'] = t('Language neutral');
  }
  return ($lang && isset($list[$lang])) ? $list[$lang] : $lang;
}

/**
 * Callback function for the 'Filter by name' facet block.
 */
function apachesolr_search_get_username($facet) {
  if (is_numeric($facet)) {
    return theme('apachesolr_breadcrumb_uid', array('field' => array('#value' => $facet)));
  }
  return '';
}

/**
 * Callback function for the 'Filter by type' facet block.
 */
function apachesolr_search_get_type($facet) {
  $type = node_type_get_name($facet);
  if ($type === FALSE && $facet == 'comment') {
    $type = t('Comment');
  }
  // A disabled or missing node type returns FALSE.
  return ($type === FALSE) ? $facet : $type;
}

/**
 * Implements hook_form_[form_id]_alter().
 *
 * This adds the 0 option to the search admin form.
 */
function apachesolr_search_form_search_admin_settings_alter(&$form, $form_state) {
  $form['indexing_throttle']['search_cron_limit']['#options']['0'] = '0';
  ksort($form['indexing_throttle']['search_cron_limit']['#options']);
}

/**
 * Implements hook_form_[form_id]_alter().
 *
 * This adds spelling suggestions, retain filters to the search form.
 */
function apachesolr_search_form_search_form_alter(&$form, $form_state) {
  if ($form['module']['#value'] == 'apachesolr_search') {
    $form['#submit'][] = 'apachesolr_search_form_search_submit';
    // No other modification make sense unless a query is active.
    // Note - this means that the query must always be run before
    // calling drupal_get_form('search_form').
    $apachesolr_has_searched = apachesolr_has_searched();

    $queryvalues = array();
    if ($apachesolr_has_searched) {
      $query = apachesolr_current_query();
      $queryvalues = $query->get_url_queryvalues();
    }

    $form['basic']['apachesolr_search']['#tree'] = TRUE;
    $form['basic']['apachesolr_search']['queryvalues'] = array(
      '#type' => 'hidden',
      '#default_value' => json_encode($queryvalues),
    );
    $form['basic']['apachesolr_search']['get'] = array(
      '#type' => 'hidden',
      '#default_value' => json_encode(array_diff_key($_GET, array('q' => 1, 'page' => 1, 'filters' => 1, 'solrsort' => 1, 'retain-filters' => 1))),
    );
    if ($queryvalues || isset($form_state['post']['apachesolr_search']['retain-filters'])) {
      $form['basic']['apachesolr_search']['retain-filters'] = array(
        '#type' => 'checkbox',
        '#title' => t('Retain current filters'),
        '#default_value' => (int) isset($_GET['retain-filters']),
      );
    }

    if (variable_get('apachesolr_search_spellcheck', TRUE) && $apachesolr_has_searched && ($response = apachesolr_static_response_cache())) {
      // Get spellchecker suggestions into an array.
      if (isset($response->spellcheck->suggestions) && $response->spellcheck->suggestions) {
        $suggestions = get_object_vars($response->spellcheck->suggestions);
        if ($suggestions) {
          // Get the original query and replace words.
          $query = apachesolr_current_query();

          foreach ($suggestions as $word => $value) {
            $replacements[$word] = $value->suggestion[0];
          }
          $new_keywords = strtr($query->get_query_basic(), $replacements);

          // Show only if suggestion is different than current query.
          if ($query->get_query_basic() != $new_keywords) {
            $form['basic']['suggestion'] = array(
              '#prefix' => '<div class="spelling-suggestions">',
              '#suffix' => '</div>',
              '#type' => 'item',
              '#title' => t('Did you mean'),
              '#value' => l($new_keywords, $query->get_path($new_keywords)),
            );
          }
        }
      }
    }
  }
}

/**
 * Added form submit function to retain filters.
 *
 * @see apachesolr_search_form_search_form_alter()
 */
function apachesolr_search_form_search_submit($form, &$form_state) {
  $fv = $form_state['values'];
  $get = json_decode($fv['apachesolr_search']['get'], TRUE);
  $queryvalues = json_decode($fv['apachesolr_search']['queryvalues'], TRUE);
  if (!empty($fv['apachesolr_search']['retain-filters']) && $queryvalues) {
    $get = $queryvalues + $get;
    $get['retain-filters'] = '1';
  }
  // Add the query values into the redirect.
  $form_state['redirect'] = array($form_state['redirect'], $get);
}

/**
 * Implements hook_form_[form_id]_alter().
 *
 * This adds options to the apachesolr admin form.
 */
function apachesolr_search_form_apachesolr_settings_alter(&$form, $form_state) {
  $form['apachesolr_search_browse'] = array(
    '#type' => 'radios',
    '#title' => t('Behavior on empty search'),
    '#options' => array(
      'none'    => t("Show search box"),
      'browse'  => t("Show search box and enabled filters' blocks under the search box"),
      'blocks'  => t("Show search box and enabled filters' blocks in their configured regions"),
      'results' => t("Show search box, enabled filters' blocks in their configured regions and first page of all available results"),
    ),
    '#default_value' => variable_get('apachesolr_search_browse', 'browse'),
    '#description' => t("This is what is shown when the user enters an empty search, or removes all filters from an active search. Remember to enable filters on the !filterslink and assign blocks to regions on the !blocklink", array(
      '!filterslink' => l('enabled filters page', 'admin/config/search/apachesolr/enabled-filters'),
      '!blocklink' => l('block settings page', 'admin/build/block'),
    )),
  );
  $form['advanced']['apachesolr_search_make_default'] = array(
    '#type' => 'radios',
    '#title' => t('Make Apache Solr Search the default'),
    '#default_value' => variable_get('apachesolr_search_make_default', 0),
    '#options' => array(0 => t('Disabled'), 1 => t('Enabled')),
    '#description' => t('Hides core node search, and makes the search block submit to Apache Solr Search'),
  );
  $form['advanced']['apachesolr_search_default_previous'] = array(
    '#type' => 'value',
    '#value' => variable_get('apachesolr_search_make_default', 0),
  );
  $form['advanced']['apachesolr_search_taxonomy_links'] = array(
    '#type' => 'radios',
    '#title' => t('Use Apache Solr for taxonomy links'),
    '#default_value' => variable_get('apachesolr_search_taxonomy_links', 0),
    '#description' => t('Note: Vocabularies that need this behavior need to be checked off on the <a href="@enabled_filters_url">enabled filters</a> settings page', array('@enabled_filters_url' => url('admin/config/search/apachesolr/enabled-filters'))),
    '#options' => array(0 => t('Disabled'), 1 => t('Enabled')),
  );
  $form['advanced']['apachesolr_search_taxonomy_previous'] = array(
    '#type' => 'value',
    '#value' => variable_get('apachesolr_search_taxonomy_links', 0),
  );

  $form['apachesolr_search_spellcheck'] = array(
    '#type' => 'checkbox',
    '#title' => t('Enable spellchecker and suggestions'),
    '#default_value' => variable_get('apachesolr_search_spellcheck', TRUE),
    '#description' => t('Enable spellchecker and get word suggestions. Also known as the "Did you mean ... ?" feature.'),
  );

  $form['#submit'][] = 'apachesolr_search_build_spellcheck';
  $form['#submit'][] = 'apachesolr_search_make_default_submit';

  if (isset($form['buttons'])) {
    // Move buttons to the bottom.
    $buttons = $form['buttons'];
    unset($form['buttons']);
    $form['buttons'] = $buttons;
  }
}

/**
 * Form submit funtion - do a menu rebuild if needed.
 *
 * @see apachesolr_search_form_apachesolr_settings_alter()
 */
function apachesolr_search_make_default_submit($form, &$form_state) {
  // We use variable_get() instead of the form values so as to also handle reset to defaults.
  if ($form_state['values']['apachesolr_search_default_previous'] != variable_get('apachesolr_search_make_default', 0) ||
      $form_state['values']['apachesolr_search_taxonomy_previous'] != variable_get('apachesolr_search_taxonomy_links', 0)) {
    // Take account of path changes
    menu_rebuild();
  }
}

/**
 * Implements hook_form_[form_id]_alter().
 *
 * Rebuild (empty) the spellcheck dictionary when the index is deleted..
 */
function apachesolr_search_form_apachesolr_delete_index_form_alter(&$form, $form_state) {
  $form['submit']['#submit'][] = 'apachesolr_search_build_spellcheck';
}

function apachesolr_search_build_spellcheck() {
  try {
    $solr = apachesolr_get_solr();
    $params['spellcheck'] = 'true';
    $params['spellcheck.build'] = 'true';
    $response = $solr->search('solr', 0, 0, $params);
  }
  catch (Exception $e) {
    watchdog('Apache Solr', nl2br(check_plain($e->getMessage())), NULL, WATCHDOG_ERROR);
  }
}

/**
 * Implements hook_theme().
 */
function apachesolr_search_theme() {
  return array(
    'apachesolr_breadcrumb_is_book_bid' => array(
      'arguments' => array('field' => NULL, 'exclude' => FALSE),
    ),
    'apachesolr_breadcrumb_uid' => array(
      'arguments' => array('field' => NULL, 'exclude' => FALSE),
    ),
    'apachesolr_breadcrumb_tid' => array(
      'arguments' => array('field' => NULL, 'exclude' => FALSE),
    ),
    'apachesolr_breadcrumb_type' => array(
      'arguments' => array('field' => NULL, 'exclude' => FALSE),
    ),
    'apachesolr_breadcrumb_language' => array(
      'arguments' => array('field' => NULL, 'exclude' => FALSE),
    ),
    'apachesolr_breadcrumb_field' => array(
      'arguments' => array('field' => NULL),
    ),
    'apachesolr_breadcrumb_changed' => array(
      'arguments' => array('field' => NULL),
      'function' => 'theme_apachesolr_breadcrumb_date_range',
    ),
    'apachesolr_breadcrumb_created' => array(
      'arguments' => array('field' => NULL),
      'function' => 'theme_apachesolr_breadcrumb_date_range',
    ),
    'apachesolr_browse_blocks' => array(
      'arguments' => array('blocks' => NULL),
    ),
    'apachesolr_currentsearch' => array(
      'arguments' => array('total_found' => NULL, 'links' => NULL),
    ),
    'apachesolr_search_snippets' => array(
      'arguments' => array('doc' => NULL, 'snippets' => NULL),
    ),
    'apachesolr_search_noresults' => array(
      'arguments' => array(),
    ),
  );
}

/**
 * Alters the function used to theme breadcrumbs
 * @param string $fieldname
 *
 */
function apachesolr_search_apachesolr_theme_breadcrumb_alter(&$fieldname) {
  $matches = preg_split('/_field_/', $fieldname);
  if (isset($matches[1])) {
    $fieldname = 'apachesolr_breadcrumb_field';
  }
}

/**
 * Theme function for fields in breadcrumbs.
 * TODO: The logic for getting here is too convoluted, and
 * there are too many bizarre naming conventions in play (_field_, _end).
 * The checks for _field_ and _end MUST get refactored.
 */
function theme_apachesolr_breadcrumb_field($vars) {
  $field = $vars['field'];
  $matches = preg_split('/_field_/', $field['#name']);
  if (isset($matches[1])) {
    $match = 'field_'.$matches[1];

    // TODO: If the apachesolr_date module is present we might
    // have fields with the suffix '_end'. These are the end-dates
    // and need the suffix removed.
    if (module_exists('apachesolr_date')) {
      $match = preg_replace('/_end{1}$/', '', $match);
    }

    //$mappings = apachesolr_cck_fields();
    $mappings = apachesolr_node_fields();
    if (isset($mappings[$match]['display_callback'])) {
      $function = $mappings[$match]['display_callback'];
      if (function_exists($function)) {
        $facet = $field['#value'];
        $options = array_merge($mappings[$match], array('delta' => $matches[1]));
        return $function($facet, $options);
      }
    }
  }
  return $field['#value'];
}

function theme_apachesolr_breadcrumb_language($vars) {
  $field = $vars['field'];
  return apachesolr_search_language_name($field['#value']);
}

/**
 * Proxy theme function for 'created' and 'changed' date fields.
 */
function theme_apachesolr_breadcrumb_date_range($vars) {
  $field = $vars['field'];
  if (preg_match('@[\[\{](\S+) TO (\S+)[\]\}]@', $field['#value'], $match)) {
    return apachesolr_date_format_range($match[1], $match[2]);
  }
  return $field['#value'];
}

/**
 * Return the username from $uid
 */
function theme_apachesolr_breadcrumb_uid($vars) {
  $field = $vars['field'];
  if ($field['#value'] == 0) {
    return variable_get('anonymous', t('Anonymous'));
  }
  else {
    return db_query("SELECT name FROM {users} WHERE uid = :uid", array(':uid' => $field['#value']))->fetchField();
  }
}

/**
 * Return the term name from $tid, or $tid as a fallback.
 */
function theme_apachesolr_breadcrumb_tid($vars) {
  $field = $vars['field'];
  if (function_exists('taxonomy_term_load')) {
    if ($term = taxonomy_term_load($field['#value'])) {
      return $term->name;
    }
  }
  return $field['#value'];
}

/**
 * Return the human readable text for a content type.
 */
function theme_apachesolr_breadcrumb_type($vars) {
  $field = $vars['field'];
  return node_type_get_name($field['#value']);
}

/**
 * Return the title of a book.
 */
function theme_apachesolr_breadcrumb_is_book_bid($vars) {
  $field = $vars['field'];
  if (is_numeric($field['#value'])) {
    return db_query('SELECT title FROM {node} WHERE nid = :nid', array(':nid' => $field['#value']))->fetchField();
  }
  else {
    return t('Not in any book');
  }
}

/**
 * Return current search block contents
 */
//function theme_apachesolr_currentsearch($total_found, $links) {
function theme_apachesolr_currentsearch($vars) {
  return theme_item_list(array(
    'items' => $vars['links'],
    'title' => format_plural($vars['total_found'], 'Search found 1 item', 'Search found @count items'),
    'type' => 'ul',
    'attributes' => array()));
}

/**
 * Theme the highlighted snippet text for a search entry.
 *
 * @param array $vars
 *
 */
function theme_apachesolr_search_snippets($vars) {
  $result = '';
  if(is_array($vars['snippets'])){
    $result = implode(' ... ', $vars['snippets']);
  }
  return $result . ' ...';
}

/**
 * Brief message to display when no results match the query.
 *
 * @see search_help()
 */
function theme_apachesolr_search_noresults() {
  return t('<ul>
<li>Check if your spelling is correct, or try removing filters.</li>
<li>Remove quotes around phrases to match each word individually: <em>"blue drop"</em> will match less than <em>blue drop</em>.</li>
<li>You can require or exclude terms using + and -: <em>big +blue drop</em> will require a match on <em>blue</em> while <em>big blue -drop</em> will exclude results that contain <em>drop</em>.</li>
</ul>');
}

function apachesolr_get_parent_terms($tids) {
  // Find the starting tid terms and then all their parents.
  $parent_terms = array();
  $new_tids = $tids;
  do {
    $query = db_select('taxonomy_term_hierarchy', 't')
      ->fields('t', array('tid', 'parent'))
      ->condition('t.tid', $new_tids, 'IN');
    $query->addTag('node_access');
    $result = $query->execute();
    $new_tids = array();
    foreach($result as $term){
      $parent_terms[$term->tid] = $term;
      if ($term->parent > 0) {
        $new_tids[] = $term->parent;
      }
    }
  } while ($new_tids);
  return $parent_terms;
}

/**
 * Return the contents of the "Current search" block.
 *
 * @param $response
 *   The Solr response object.
 * @param $query
 *   The Solr query object.
 */
function apachesolr_search_currentsearch_block($response, $query) {
  $fields = $query->get_filters();
  $links = array();
  $facets = array();

  // If current search has keys, offer current search without them
  if ($keys = $query->get_query_basic()) {
    $links[] = theme('apachesolr_unclick_link', array(
      'facet_text' => $keys,
      'path' => $query->get_path(''),
      'options' => array('query' => $query->get_url_queryvalues())));
  }
  // Find all taxonomy terms to be treated in a hierarchy.
  if (module_exists('taxonomy')) {
    $reflect_hierarchy = apachesolr_search_get_hierarchical_vocabularies();
    $facets = array();
    foreach ($fields as $index => $field) {
      if ($field['#name'] && 'tid' == $field['#name']) {
        $term = taxonomy_term_load($field['#value']);
        if ($reflect_hierarchy[$term->vid]) {
          $fields[$index] += array('#parent' => 0, '#children' => array());
          // Just save the index for later lookup.
          $facets[$term->tid] = $index;
        }
      }
    }
    if ($facets) {
      // Get all term hierarchy information.
      $all_terms = apachesolr_get_parent_terms(array_keys($facets));
      foreach ($all_terms as $tid => $term) {
        if (!isset($facets[$tid])) {
          // This is a parent that is missing from the query.  E.g. we started
          // on a taxonomy/term/$tid page.
          $query->add_filter('tid', $tid);
          // Ordering is wonky, but oh well...
          $fields[] = array('#name' => 'tid', '#value' => $tid, '#exclude' => FALSE, '#parent' => 0, '#children' => array());
          // Get the index of the newly added facet.
          end($fields);
          $facets[$tid] = key($fields);
        }
      }
      foreach ($all_terms as $tid => $term) {
        $index = $facets[$term->tid];
        if (isset($facets[$term->parent])) {
          // Use a reference so we see the updated data.
          $fields[$facets[$term->parent]]['#children'][] = &$fields[$index];
          $fields[$index]['#parent'] = $term->parent;
        }
      }
    }
  }

  // We don't directly render any items with a parent.
  foreach ($fields as $index => $field) {
    $fields[$index]['#active'] = TRUE;
    if (!empty($fields[$index]['#parent']) || !$field['#name']) {
      // We will render it via its parent.
      unset($fields[$index]);
    }
  }

  $links = array_merge($links, apachesolr_search_nested_facet_items($query, $fields, $response->response->numFound, FALSE));
  if ($links) {
    $content = theme('apachesolr_currentsearch', array('total_found' => $response->response->numFound, 'links' => $links));
    return array('subject' => t('Current search'), 'content' => $content);
  }
}

/**
 * Return an array of taxonomy facets that should be displayed hierarchically.
 */
function apachesolr_search_get_hierarchical_vocabularies() {
  static $result;

  if (!isset($result)) {
    $result = array();
    if (function_exists('taxonomy_get_vocabularies')) {
      $vocabularies = taxonomy_get_vocabularies();
      $force_flat = variable_get('apachesolr_search_force_flat_vocabularies', array());
      foreach ($vocabularies as $voc) {
        // If the vocabulary is not multiple-parent hierarchical and not
        // freetagging and not designated to be forced to display flat.
        if ($voc->hierarchy != 2 /* (TODO: not sure how to handle this in d7 so just commenting this out) && $voc->tags != 1*/ && empty($force_flat[$voc->vid])) {
          $result[$voc->vid] = 1;
        }
      }
    }
  }

  return $result;
}
