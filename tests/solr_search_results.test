<?php
// $Id: solr_search_results.test,v 1.1.2.1 2008/06/07 00:18:49 drunkenmonkey Exp $

class DrupalSolrSearchResultTests extends DrupalTestCase {
  function get_info() {
    return array('name' => 'Solr/search results',
      'desc' => 'Assure that searches with apachesolr yield correct results.',
      'group' => 'Apache Solr tests');
  }

  // Default Apache Solr stop words.
  static $stop_words = array('a', 'an', 'and', 'are', 'as', 'at', 'be', 'but', 'by',
    'for', 'if', 'in', 'into', 'is', 'it', 'no', 'not', 'of', 'on', 'or', 's', 'such',
    't', 'that', 'the', 'their', 'then', 'there', 'these', 'they', 'this', 'to',
    'was', 'will', 'with');

  // Tests, whether the search finds an existing node with an appropriate query.
  function testFindsNode($nid = 1) {
    $node = node_load($nid);

    if (empty($node)) {
      return TRUE;
    }

    $word = self::_select_word($node->body);
    if ($word == NULL) {
      return $this->testFindsNode($nid + 1);
    }

    $results = apachesolr_search_search('search', $word);
    $contained = FALSE;
    $url = url('node/' . $nid, array('absolute' => TRUE));
    foreach ($results as $result) {
      if ($result['link'] == $url) {
        $contained = TRUE;
        break;
      }
    }

    return $this->assertTrue($contained,
        t('Node with appropriate content should be found') . '. Link: ' . $url . '. Word: ' . $word);
  }

  // Tests, if the AND/OR operators work correctly.
  function testAndOr() {
    $result = TRUE;
    $word1 = $word2 = NULL;
    $nid = 1;
    while ($word1 == null) {
      $node = node_load($nid++);
      $word1 = self::_select_word($node->body);
    }
    while ($word2 == null) {
      $node = node_load($nid++);
      $word2 = self::_select_word($node->body);
    }

    $results1 = apachesolr_search_search('search', $word1);
    $results2 = apachesolr_search_search('search', $word2);
    $resultsAnd = apachesolr_search_search('search',
        $word1 . ' AND ' . $word2);
    $resultsOr = apachesolr_search_search('search',
        $word1 . ' OR ' . $word2);

    $incommon = 0;
    $tmp_list = array();
    foreach ($results1 as $result) {
      $tmp_list[$result['link']] = TRUE;
    }
    foreach ($results2 as $result) {
      if (isset($tmp_list[$result['link']])) {
        ++$incommon;
      }
    }

    $resultCount1 = count($results1);
    $resultCount2 = count($results2);
    // Expected ´count($resultsOr)´; max. 10, because this is search limit
    $expOrCount = min($resultCount1 + $resultCount2 - $incommon, 10);
    // AND count cannot be predicted exactly, because total number of matches is unknown.
    // Therefore, $incommon is used as minimum value.

    $result &= $this->assertEqual($expOrCount, count($resultsOr),
        t("'!msg' OR should yield the correct number of results", array('!msg' => '%s')));
    $result &= $this->assertTrue($incommon <= count($resultsOr),
        t('AND should yield the correct number of results'));

    return $result;
  }

  // Tests, whether field specifications such as 'nid:1' work.
  function testFindFields() {
    $result = TRUE;
    $node = node_load(1);
    $url = url('node/1', array('absolute' => TRUE));

    $nidResult1 = apachesolr_search_search('search', 'nid:1');
    $nidResult2 = apachesolr_search_search('search', 'nid:2');
    $nidResult3 = apachesolr_search_search('search', 'nid:1 OR nid:2');
    $result &= $this->assertEqual(1, count($nidResult1),
        t("'!msg' Searched for node #!num", array('!num' => '1', '!msg' => '%s')));
    $result &= $this->assertEqual(1, count($nidResult2),
        t("'!msg' Searched for node #!num", array('!num' => '2', '!msg' => '%s')));
    $result &= $this->assertEqual(2, count($nidResult3),
        t("'!msg' Searched for nodes #!num1 and #!num2",
            array('!num1' => '1', '!num2' => '2', '!msg' => '%s')));

    $typeResult = apachesolr_search_search('search', 'type:' . $node->type);
    $contained = FALSE;
    $only_right_type = TRUE;
    $type = node_get_types('name', $node);
    foreach ($typeResult as $item) {
      if ($item['link'] == $url) {
        $contained = TRUE;
      }
      if ($item['type'] != $type) {
        $only_right_type = FALSE;
      }
    }
    $result &= $this->assertTrue($contained,
        t('Searched for node #!num through !type search',
            array('!num' => '1', '!type' => 'type')));
    $result &= $this->assertTrue($only_right_type,
        t('Searched for nodes of type @type', array('@type' => $node->type)));

    $uidResult = apachesolr_search_search('search', 'uid:' . $node->uid);
    $contained = FALSE;
    $only_right_user = TRUE;
    $themed_user = theme('username', $node);
    foreach ($uidResult as $item) {
      if ($item['link'] == $url) {
        $contained = TRUE;
      }
      if ($item['user'] != $themed_user) {
        $only_right_user = FALSE;
      }
    }
    $result &= $this->assertTrue($contained,
        t('Searched for node #!num through !type search',
            array('!num' => '1', '!type' => 'uid')));
    $result &= $this->assertTrue($only_right_user,
        t('Searched for nodes authored by !user',
            array('!user' => $node->name, '!msg' => '%s')));

    $titleComp = self::_select_word($node->title);
    if ($titleComp == null) {
      return $result;
    }
    $titleResult = apachesolr_search_search('search', 'title:' . $titleComp);
    $contained = false;
    foreach ($uidResult as $item) {
      if ($item['link'] == $url) {
        $contained = TRUE;
      }
    }
    $result &= $this->assertTrue($contained,
        t('Searched for node #!num through !type search',
            array('!num' => '1', '!type' => 'title')));

    return $result;
  }

  // Selects a word from the text that is not in the stop word list.
  static function _select_word($text) {
    $words = preg_split('/\W+/', $text);
    foreach ($words as $w) {
      $w = strtolower($w);
      if (array_search($w, self::$stop_words) === FALSE) {
        return $w;
      }
    }
    return NULL;
  }
}
