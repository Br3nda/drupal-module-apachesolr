<?php
// $Id: apachesolr_attachments.module,v 1.1.2.5 2008/12/01 18:24:42 febbraro Exp $

/**
 * @file
 *   Provides a file attachment search implementation for use with the Apache Solr module
 */

define('SOLR_ATTACHMENT_WD', 'Solr Attachments');

/**
 * Implementation of hook_menu().
 */
function apachesolr_attachments_menu() {
  $items = array();  
  $items['admin/settings/apachesolr/attachments'] = array(
    'title' => 'Apache Solr Attachments Settings',
    'description' => 'Administer Apache Solr Attachments.',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('apachesolr_attachments_settings'),
    'access callback' => 'user_access',
    'access arguments' => array('administer site configuration'),
  );
  return $items;
}

/**
 * Displays the Attachment Settings Form.
*/
function apachesolr_attachments_settings() {
  $instruction_text = 'For each type of attachment, enter the path to the helper application installed on your server. "%file%" is a placeholder for the path of the attachment file and is required. If you don\'t want to search a type of attachment, leave the path setting blank (i.e., remove the content from the appropriate field below).';	

  $form['instructions'] = array(
    '#type' => 'markup',
    '#value' => t($instruction_text)
  );

  $form['apachesolr_attachment_pdf_path'] = array(
    '#type' => 'textfield',
    '#title' => t('PDF Helper'),
    '#size' => 50,
    '#maxlength' => 100,
    '#description' =>  t("The full path to the helper for application/pdf files, plus any other parameters needed by the helper."),
    '#default_value' => variable_get('apachesolr_attachment_pdf_path', ''),
  );
  $form['apachesolr_attachment_txt_path'] = array(
    '#type' => 'textfield',
    '#title' => t('Text Helper'),
    '#size' => 50,
    '#maxlength' => 100,
    '#description' =>  t("The full path to the helper for text/plain files, plus any other parameters needed by the helper."),
    '#default_value' => variable_get('apachesolr_attachment_txt_path', ''),
  );
  $form['apachesolr_attachment_doc_path'] = array(
    '#type' => 'textfield',
    '#title' => t('Word Doc Helper'),
    '#size' => 50,
    '#maxlength' => 100,
    '#description' =>  t("The full path to the helper for application/msword files, plus any other parameters needed by the helper."),
    '#default_value' => variable_get('apachesolr_attachment_doc_path', ''),
  );
   
  return system_settings_form($form);
}

/**
 * Implementation of hook_search().
 */
function apachesolr_attachments_search($op = 'search', $keys = NULL) {

  switch ($op) {
    case 'name':
      return ''; // We dont want a tab
    case 'reset':
      variable_del('apachesolr_attachment_last_change');
      variable_del('apachesolr_attachment_last_nid');
      return;
    case 'status':
      // TODO: Figure out a way to know how many actual files are left to update.
      return apachesolr_index_status(variable_get('apachesolr_attachment_last_change', 0), variable_get('apachesolr_attachment_last_nid', 0));
    case 'search':
      return apachesolr_search_search($op, $keys);
  }
}

/**
 * Hook is called by search.module to add things to the search index.
 * In our case we will search content types and add any CCK type that
 * is a file type that we know how to parse and any uploaded file
 * attachments.
 */
function apachesolr_attachments_update_index() {

  $last_change = variable_get('apachesolr_attachment_last_change', 0);
  $last_nid = variable_get('apachesolr_attachment_last_nid', 0);
  // TODO - should probably have a separate variable.
  $cron_limit = variable_get('search_cron_limit', 100);
  
  $result = apachesolr_get_nodes_to_index($last_change, $last_nid, $cron_limit);
  $success = apachesolr_index_nodes($result, 'apachesolr_attachment_add_documents');
  if ($success) {
    variable_set('apachesolr_attachment_last_change', $success['last_change']);
    variable_set('apachesolr_attachment_last_nid',  $success['last_nid']);
  }
}

/**
 * Callback for apachesolr_index_nodes().
 *
 * Adds a document for each indexable file attachment for the given node ID.
 */
function apachesolr_attachment_add_documents(&$documents, $nid) {
  $node = node_load($nid, NULL, TRUE);
  if (!empty($node->nid)) {
    
    $hash = apachesolr_site_hash();

    // Since there is no notification for an attachment being unassociated with a 
    // node (but that action will trigger it to be indexed again), lets remove 
    // all indexed attachments then add all attached (if any)
    _asa_remove_attachments_from_index($node->nid);

    $files = _asa_get_indexable_files($node);
    if(!empty($files)) {
      foreach ($files as $file) {
        // Some are arrays others are objects, treat them all as objects
        $file = (object) $file;

        $text = _asa_get_attachment_text($file);
        $text = trim($text);

        if ($text) {
          $document = new Apache_Solr_Document();
          $document->id = apachesolr_document_id($file->fid, 'file');
          $document->url = file_create_url($file->filepath);
          $document->hash = $hash;
          $document->nid = $node->nid;
          $document->title = $file->filename; 
          $document->changed = $node->changed;
          $document->uid = $node->uid;
          $document->name = $node->name;
          $document->body = $text;
          $document->text = "{$file->description} {$file->filename} $text";
          $document->type = $node->type;
          $document->bsfield_isfile = TRUE;
          _as_configure_taxonomy($document, $node);
          
          $documents[] = $document;
        }
      }
    }
  }
}

/**
 * Implementation of hook_nodeapi().
 *
 * For a delete: Remove all associated attachments from the Solr store.
 */
function apachesolr_attachments_nodeapi($node, $op) {

  switch ($op) {
    case 'delete':
      _asa_remove_attachments_from_index($node->nid);
      break;
  }
}

/**
 * Implementation of hook_apachesolr_process_results().
 *
 * When using the core Apache Solr module, everythign is treated as a node and as such 
 * the link and type wont be configured correctly if it is a file attachement, so override 
 * those values here if needed. 
 */
function apachesolr_attachments_apachesolr_process_results($results) {

  if (is_array($results)) {
    foreach ($results as &$item) {
      if (isset($item['node']->bsfield_isfile) && $item['node']->bsfield_isfile === TRUE) {
        $nid = $item['node']->nid;
        $node_title = db_result(db_query("SELECT title FROM {node} WHERE nid = %d", $nid));
        $item['snippet'] = l($node_title, "node/$nid") . ': ' . $item['snippet'];
      }
    }
  }
}

/**
 * Return all file attachments for a particular node
 */
function _asa_get_indexable_files($node) {
  $files = array();

  if(!empty($node->files)) {
    $files = array_merge($files, $node->files);
  }

  $fields = _asa_get_cck_file_fields();
  foreach ($fields as $field) {
    if(!empty($node->$field)) {
      $files = array_merge($files, $node->$field);
    }
  }

  return $files;
}

/**
 * Return all CCK fields that are of type 'file'
 */
function _asa_get_cck_file_fields() {
  $file_fields = array();
  if(module_exists('filefield')) {
    $fields = content_fields();
    foreach($fields as $key => $values){
      if($values['type'] == 'filefield') {
        $file_fields[] = $key;
      }
    }
  }
  return $file_fields;
}

/**
 * Parse the Attachment getting just the raw text, stripping any garbage characters that
 * could screw up the XML Doc processing.
 */
function _asa_get_attachment_text($file) {
  $helper_command = _asa_get_file_helper_command($file->filemime);

  // Empty entries in settings mean that helper is disabled.
  if ($helper_command == '')
    return '';
    
  // %file% is a token that is placed in the helper's parameter list to represent
  // the file path to the attachment.
  $helper_command = preg_replace('/%file%/', "$file->filepath", $helper_command);  
  $helper_command = escapeshellcmd($helper_command);

  $text = shell_exec($helper_command);
  
  // Strip anything that might make the Solr integration barf.
  // Wierd control characters make things behave wierd, especially in XML
  $cleaned_text = iconv("utf-8", "utf-8//IGNORE", $text);

  // As per robertDouglass - http://drupal.org/node/335871
  // Bad control character. Do we need to make a hook for text cleanup?
  $cleaned_text = preg_replace('/\x0C/', '', $cleaned_text);
  
  return $cleaned_text;
}

/**
 * For a particular node id, remove all file attachments from the solr index.
 */
function _asa_remove_attachments_from_index($nid) {
  try {
    $solr = apachesolr_get_solr();
    $solr->deleteByQuery("nid:{$nid} AND bsfield_isfile:true");
    $solr->commit();
  }
  catch (Exception $e) {
    watchdog(SOLR_ATTACHMENT_WD, $e->getMessage(), WATCHDOG_ERROR);
  }
}

/**
 * Get the command to parse text out of a particular mime type.
 */
function _asa_get_file_helper_command($type) {

  // Determine helper based on file extension
  switch ($type) {
    case 'application/pdf':
      $cmd = variable_get('apachesolr_attachment_pdf_path','');
      break;
    case 'text/plain':
      $cmd = variable_get('apachesolr_attachment_txt_path','');
      break;
    case 'application/msword':
      $cmd = variable_get('apachesolr_attachment_doc_path','');
      break;
    default:
      $cmd = '';
  }
  return $cmd;
}

/***************************************************************************************/
/** The following functions should become part of the Apache Solr module API          **/
/***************************************************************************************/

/**
 * Add taxonomy from the node to the solr document for the attachment.
 *
 * This is a direct copy from the apachesolr.module, we should refactor to 
 * make it reusable
 */
function _as_configure_taxonomy(&$document, $node) {
  
  if (is_array($node->taxonomy)) {
    foreach ($node->taxonomy as $term) {
      // Double indexing of tids lets us do effecient searches (on tid)
      // and do accurate per-vocabulary faceting.

      // By including the ancestors to a term in the index we make 
      // sure that searches for general categories match specific
      // categories, e.g. Fruit -> apple, a search for fruit will find
      // content categorized with apple.
      $ancestors = taxonomy_get_parents_all($term->tid);
      foreach ($ancestors as $ancestor) {
        $document->setMultiValue('tid', $ancestor->tid);
        $document->setMultiValue('imfield_vid'. $ancestor->vid, $ancestor->tid);
        $document->setMultiValue('vid', $ancestor->vid);
        $document->setMultiValue('taxonomy_name', $ancestor->name);
      }
    }
  }
}
